function Difficulty(rows, columns, number_mines, time_limit, name, id) {
    this.rows = rows;
    this.columns = columns;
    this.number_mines = number_mines;
    this.time_limit = time_limit;
    this.name = name;
    this.id = id;
}

// Changed to 3 difficulty levels
let DIFFICULTY = [
    new Difficulty(9, 9, 10, 300, "Easy", "easy"),      // Easy: 9√ó9, 10 mines
    new Difficulty(16, 16, 40, 600, "Medium", "medium"),   // Medium: 16√ó16, 40 mines
    new Difficulty(16, 30, 99, 900, "Hard", "hard")      // Hard: 16√ó30, 99 mines
];

let currentDifficultyIndex = 0;  // Current difficulty index, default is Easy
let gameBoard = [];
let mineLocations = [];
let gameStarted = false;
let gameOver = false;

// Disable difficulty buttons
function disableDifficultyButtons() {
    const buttons = ['easyBtn', 'mediumBtn', 'hardBtn'];
    buttons.forEach(btnId => {
        const btn = document.getElementById(btnId);
        if (btn) {
            btn.disabled = true;
            btn.classList.add('disabled');
        }
    });
}

// Enable difficulty buttons
function enableDifficultyButtons() {
    const buttons = ['easyBtn', 'mediumBtn', 'hardBtn'];
    buttons.forEach(btnId => {
        const btn = document.getElementById(btnId);
        if (btn) {
            btn.disabled = false;
            btn.classList.remove('disabled');
        }
    });
}

// Difficulty switch function
function switchDifficulty(difficultyIndex) {
    // If the game is in progress, prevent switching
    if (gameStarted && !gameOver) {
        console.log('Game in progress, cannot switch difficulty');
        return;
    }
    
    // Stop the current game
    if (typeof endGameWithoutSaving === 'function') {
        endGameWithoutSaving();
    }
    
    // Update difficulty index
    currentDifficultyIndex = difficultyIndex;
    const currentDifficulty = DIFFICULTY[currentDifficultyIndex];
    
    // Reset game state
    gameOver = false;
    gameStarted = false;
    
    // Update button styles
    updateDifficultyButtonStyles(difficultyIndex);
    
    // Re-create game board
    createGameBoard();
    
    // Update counters
    if (typeof setTotalMines === 'function') {
        setTotalMines(currentDifficulty.number_mines);
    }
    
    // Reset timer
    if (typeof resetGameTimer === 'function') {
        resetGameTimer();
    }
    
    console.log(`Switched to ${currentDifficulty.name} difficulty: ${currentDifficulty.rows}√ó${currentDifficulty.columns}, ${currentDifficulty.number_mines} mines`);
}

// Update difficulty button styles
function updateDifficultyButtonStyles(activeIndex) {
    const buttons = ['easyBtn', 'mediumBtn', 'hardBtn'];
    buttons.forEach((btnId, index) => {
        const btn = document.getElementById(btnId);
        if (btn) {
            if (index === activeIndex) {
                btn.classList.add('active');
            } else {
                btn.classList.remove('active');
            }
        }
    });
}

// Create game board
function createGameBoard() {
    const gameBoardElement = document.getElementById("gameBoard");
    const currentDifficulty = DIFFICULTY[currentDifficultyIndex];
    const rows = currentDifficulty.rows;
    const cols = currentDifficulty.columns;
    
    // Clear the existing game board
    gameBoardElement.innerHTML = "";
    
    // Dynamically adjust CSS grid
    gameBoardElement.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;
    gameBoardElement.style.gridTemplateRows = `repeat(${rows}, 1fr)`;
    
    // Adjust board size based on difficulty
    adjustGameBoardSize(currentDifficulty);
    
    // Create cells
    for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
            const cell = document.createElement("div");
            cell.classList.add("cell");
            cell.dataset.row = r;
            cell.dataset.col = c;
            
            cell.addEventListener("click", function() {
                handleCellClick(r, c);
            });
            
            cell.addEventListener("contextmenu", function(e) {
                e.preventDefault(); 
                handleRightClick(r, c);
            });
            
            gameBoardElement.appendChild(cell);
        }
    }
    
    initializeGameBoard();
    
    // Initial state: board is not interactive
    gameBoardElement.classList.add("game-not-started");
}

// Adjust board size
function adjustGameBoardSize(difficulty) {
    const gameBoardElement = document.getElementById("gameBoard");
    let cellSize;
    
    // Set different cell sizes based on difficulty
    if (difficulty.name === "Easy") {
        cellSize = 5; // Larger cells for easy
    } else if (difficulty.name === "Medium") {
        cellSize = 4; // Medium size for medium
    } else if (difficulty.name === "Hard") {
        cellSize = 4; // Smaller cells for hard, fit more cells
    }
    
    const boardWidth = difficulty.columns * cellSize;
    const boardHeight = difficulty.rows * cellSize;
    
    gameBoardElement.style.width = `${boardWidth}vh`;
    gameBoardElement.style.height = `${boardHeight}vh`;
}

// Start the game (called when Start button is pressed)
function startGame() {
    gameStarted = true;
    disableDifficultyButtons(); // Disable difficulty buttons
    console.log('Game started, difficulty buttons disabled');
}

// Game end handler
function gameEndHandler() {
    gameStarted = false;
    gameOver = true;
}

window.addEventListener("DOMContentLoaded", () => {
    // Initialize as Easy difficulty
    switchDifficulty(0);
    
    // Add difficulty button event listeners
    const easyBtn = document.getElementById('easyBtn');
    const mediumBtn = document.getElementById('mediumBtn');
    const hardBtn = document.getElementById('hardBtn');
    
    if (easyBtn) easyBtn.addEventListener('click', () => switchDifficulty(0));
    if (mediumBtn) mediumBtn.addEventListener('click', () => switchDifficulty(1));
    if (hardBtn) hardBtn.addEventListener('click', () => switchDifficulty(2));
});

// Restart button event listener
document.addEventListener("DOMContentLoaded", () => {
    const restartButton = document.getElementById("restartButton");
    if (restartButton) {
        restartButton.addEventListener("click", function () {
            restartGame();
        });
    }
});

function restartGame() {
    // Hide the restart button
    document.getElementById("restartButton").style.display = "none";
    
    // Reset game state
    gameOver = false;
    gameStarted = false;
    
    // Re-enable difficulty buttons
    enableDifficultyButtons();

    // Re-create the current difficulty game board
    createGameBoard();
    
    // Reset mine count for the counter
    const currentDifficulty = DIFFICULTY[currentDifficultyIndex];
    if (typeof setTotalMines === 'function') {
        setTotalMines(currentDifficulty.number_mines);
    }
    
    // Show the start button
    const startButton = document.getElementById("startButton");
    if (startButton) {
        startButton.style.display = "block";
    }
    
    console.log('Game restarted, difficulty buttons enabled');
}

function initializeGameBoard() {
    const currentDifficulty = DIFFICULTY[currentDifficultyIndex];
    const rows = currentDifficulty.rows;
    const cols = currentDifficulty.columns;
    
    gameBoard = new Array(rows);
    for (let r = 0; r < rows; r++) {
        gameBoard[r] = new Array(cols);
        for (let c = 0; c < cols; c++) {
            gameBoard[r][c] = {
                hasMine: false,
                isRevealed: false,
                isFlagged: false,
                isQuestioned: false,  // NEW: is question-mark state
                adjacentMines: 0
            };
        }
    }
    placeMines();
    calculateAdjacentMines();
}

function placeMines() {
    const currentDifficulty = DIFFICULTY[currentDifficultyIndex];
    const rows = currentDifficulty.rows;
    const cols = currentDifficulty.columns;
    const mineCount = currentDifficulty.number_mines;
    
    let positions = [];
    for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
            positions.push([r, c]);
        }
    }
    
    for (let i = positions.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [positions[i], positions[j]] = [positions[j], positions[i]];
    }
    
    mineLocations = [];
    for (let i = 0; i < mineCount && i < positions.length; i++) {
        const [r, c] = positions[i];
        gameBoard[r][c].hasMine = true;
        mineLocations.push([r, c]);
    }
}

function calculateAdjacentMines() {
    const currentDifficulty = DIFFICULTY[currentDifficultyIndex];
    const rows = currentDifficulty.rows;
    const cols = currentDifficulty.columns;
    
    for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
            if (gameBoard[r][c].hasMine) continue;
            
            let count = 0;
            
            for (let dr = -1; dr <= 1; dr++) {
                for (let dc = -1; dc <= 1; dc++) {
                    if (dr === 0 && dc === 0) continue;
                    
                    const nr = r + dr;
                    const nc = c + dc;
                    
                    if (nr >= 0 && nr < rows && nc >= 0 && nc < cols) {
                        if (gameBoard[nr][nc].hasMine) {
                            count++;
                        }
                    }
                }
            }
            
            gameBoard[r][c].adjacentMines = count;
        }
    }
}

function handleCellClick(row, col) {
    // Check game state
    const gameBoardElement = document.getElementById("gameBoard");
    if (gameBoardElement && gameBoardElement.classList.contains("game-not-started")) {
        return; // If game hasn't started, ignore click
    }
    
    if (gameOver || gameBoard[row][col].isRevealed) return;
    // If cell is flagged or questioned, cannot left-click
    if (gameBoard[row][col].isFlagged || gameBoard[row][col].isQuestioned) return;
    
    const cellElement = getCellElement(row, col);
    
    gameBoard[row][col].isRevealed = true;
    cellElement.classList.add("revealed");
    
    // Increase explored cell count (only count on first click)
    if (typeof addExploredCell === 'function') {
        addExploredCell();
    }
    
    if (gameBoard[row][col].hasMine) {
        cellElement.classList.add("mine");
        cellElement.innerHTML = "üí£";
        endGame(false);
    } else {
        const adjacentMines = gameBoard[row][col].adjacentMines;
        if (adjacentMines > 0) {
            cellElement.textContent = adjacentMines;
            cellElement.classList.add(`adjacent-${adjacentMines}`);
        } else {
            revealSurroundingCells(row, col);
        }
        checkForWin();
    }
}

function handleRightClick(row, col) {
    // Check game state
    const gameBoardElement = document.getElementById("gameBoard");
    if (gameBoardElement && gameBoardElement.classList.contains("game-not-started")) {
        return; // If game hasn't started, ignore right-click
    }
    
    if (gameOver || gameBoard[row][col].isRevealed) return;
    
    const cellElement = getCellElement(row, col);
    
    // Cycle through three states: unmarked ‚Üí flag ‚Üí question ‚Üí unmarked
    if (!gameBoard[row][col].isFlagged && !gameBoard[row][col].isQuestioned) {
        // State 1: unmarked ‚Üí flag
        gameBoard[row][col].isFlagged = true;
        gameBoard[row][col].isQuestioned = false;
        cellElement.classList.add("flagged");
        cellElement.classList.remove("questioned");
        cellElement.innerHTML = "üö©";
        
        // Increase flag count
        if (typeof addFlag === 'function') {
            addFlag();
        }
        
    } else if (gameBoard[row][col].isFlagged && !gameBoard[row][col].isQuestioned) {
        // State 2: flag ‚Üí question
        gameBoard[row][col].isFlagged = false;
        gameBoard[row][col].isQuestioned = true;
        cellElement.classList.remove("flagged");
        cellElement.classList.add("questioned");
        cellElement.innerHTML = "‚ùì";
        
        // Decrease flag count (from flag to question)
        if (typeof removeFlag === 'function') {
            removeFlag();
        }
        
    } else if (!gameBoard[row][col].isFlagged && gameBoard[row][col].isQuestioned) {
        // State 3: question ‚Üí unmarked
        gameBoard[row][col].isFlagged = false;
        gameBoard[row][col].isQuestioned = false;
        cellElement.classList.remove("flagged");
        cellElement.classList.remove("questioned");
        cellElement.innerHTML = "";
        
        // From question to unmarked, counter does not change
    }
    
    checkForWin();
}

function revealSurroundingCells(row, col) {
    const currentDifficulty = DIFFICULTY[currentDifficultyIndex];
    const rows = currentDifficulty.rows;
    const cols = currentDifficulty.columns;
    
    for (let dr = -1; dr <= 1; dr++) {
        for (let dc = -1; dc <= 1; dc++) {
            if (dr === 0 && dc === 0) continue;
            
            const nr = row + dr;
            const nc = col + dc;
            
            if (nr >= 0 && nr < rows && nc >= 0 && nc < cols && 
                !gameBoard[nr][nc].isRevealed && 
                !gameBoard[nr][nc].isFlagged && 
                !gameBoard[nr][nc].isQuestioned) {
                handleCellClick(nr, nc);
            }
        }
    }
}

function getCellElement(row, col) {
    return document.querySelector(`.cell[data-row="${row}"][data-col="${col}"]`);
}

function checkForWin() {
    if (gameOver) return;
    
    const currentDifficulty = DIFFICULTY[currentDifficultyIndex];
    const rows = currentDifficulty.rows;
    const cols = currentDifficulty.columns;
    const totalCells = rows * cols;
    const totalMines = currentDifficulty.number_mines;
    
    let revealedCount = 0;
    for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
            if (gameBoard[r][c].isRevealed && !gameBoard[r][c].hasMine) {
                revealedCount++;
            }
        }
    }
    
    if (revealedCount === totalCells - totalMines) {
        endGame(true);
    }
}

function endGame(isWin) {
    gameOver = true;
    gameStarted = false;
    
    // Re-enable difficulty buttons
    gameEndHandler();
    
    // Stop timer (if exists)
    if (typeof stopGameTimer === 'function') {
        stopGameTimer();
    }
    
    // Hide End Game button
    const endButton = document.getElementById("endButton");
    if (endButton) {
        endButton.style.display = "none";
    }
    
    revealAllMines();
    document.getElementById("restartButton").style.display = "block";
    
    setTimeout(() => {
        const currentDifficulty = DIFFICULTY[currentDifficultyIndex];
        if (isWin) {
            alert(`üéâ Congratulations! You won on ${currentDifficulty.name} difficulty!`);
        } else {
            alert(`üí• Game over! You hit a mine on ${currentDifficulty.name} difficulty!`);
        }
        
        // After alert, record player score (both win and loss are recorded)
        if (typeof saveTimerValue === 'function' && typeof gameSeconds !== 'undefined') {
            // Format time
            const hours = Math.floor(gameSeconds / 3600);
            const minutes = Math.floor((gameSeconds % 3600) / 60);
            const secs = gameSeconds % 60;
            
            const formattedTime = [
                hours.toString().padStart(2, '0'),
                minutes.toString().padStart(2, '0'),
                secs.toString().padStart(2, '0')
            ].join(':');
            
            // Save score (record both win and loss, include difficulty)
            saveTimerValue(formattedTime, gameSeconds, isWin, currentDifficulty);
            
            if (isWin) {
                console.log(`üèÜ Player won on ${currentDifficulty.name} difficulty! Time: ${formattedTime} (${gameSeconds} seconds)`);
            } else {
                console.log(`üí• Game lost on ${currentDifficulty.name} difficulty, time: ${formattedTime} (${gameSeconds} seconds)`);
            }
        }
    }, 500);
}

function revealAllMines() {
    mineLocations.forEach(([r, c]) => {
        const cellElement = getCellElement(r, c);
        
        if (!gameBoard[r][c].isRevealed) {
            cellElement.classList.add("revealed", "mine");
            cellElement.innerHTML = "üí£";
        }
    });
}

// Reset game board (do not save data)
function resetGameBoard() {
    // Reset game state
    gameOver = false;
    gameStarted = false;
    
    // Re-enable difficulty buttons
    enableDifficultyButtons();

    // Re-create the current difficulty game board
    createGameBoard();
}
