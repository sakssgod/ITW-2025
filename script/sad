function Difficulty(rows, columns, number_mines, time_limit, name, id) {
    this.rows = rows;
    this.columns = columns;
    this.number_mines = number_mines;
    this.time_limit = time_limit;
    this.name = name;
    this.id = id;
}

// Modified to 3 difficulty levels
let DIFFICULTY = [
    new Difficulty(9, 9, 10, 300, "Easy", "easy"),      // Easy: 9√ó9, 10 mines
    new Difficulty(16, 16, 40, 600, "Medium", "medium"),   // Medium: 16√ó16, 40 mines
    new Difficulty(16, 30, 99, 900, "Hard", "hard")      // Hard: 16√ó30, 99 mines
];

let currentDifficultyIndex = 0;  // Current difficulty index, default is Easy
let gameBoard = [];
let mineLocations = [];
let gameStarted = false;
let gameOver = false;
let firstClickMade = false; // Track whether the first click has been made

// üÜï Lives mode related variables
let livesMode = false;        // Whether it is lives mode
let currentLives = 3;         // Current number of lives
let maxLives = 3;             // Maximum number of lives

// Disable difficulty buttons
function disableDifficultyButtons() {
    const buttons = ['easyBtn', 'mediumBtn', 'hardBtn'];
    buttons.forEach(btnId => {
        const btn = document.getElementById(btnId);
        if (btn) {
            btn.disabled = true;
            btn.classList.add('disabled');
        }
    });
}

// Enable difficulty buttons
function enableDifficultyButtons() {
    const buttons = ['easyBtn', 'mediumBtn', 'hardBtn'];
    buttons.forEach(btnId => {
        const btn = document.getElementById(btnId);
        if (btn) {
            btn.disabled = false;
            btn.classList.remove('disabled');
        }
    });
}

// üÜï Game mode switch function
function switchGameMode(isLivesMode) {
    // If the game is in progress, ask for confirmation
    if (gameStarted && !gameOver) {
        if (!confirm('Switching the game mode will end the current game. Are you sure you want to continue?')) {
            return;
        }
        endGameWithoutSaving();
    }
    
    livesMode = isLivesMode;
    currentLives = maxLives;
    
    // Update mode button styles
    updateModeButtons();
    
    // Update lives display
    updateLivesDisplay();
    
    // Reset game
    if (typeof resetGameTimer === 'function') {
        resetGameTimer();
    }
    
    console.log(`Switched to ${livesMode ? 'Lives Mode' : 'Classic Mode'}`);
}

// üÜï Update mode button styles
function updateModeButtons() {
    const classicBtn = document.getElementById('classicModeBtn');
    const livesBtn = document.getElementById('livesModeBtn');
    
    if (classicBtn && livesBtn) {
        if (livesMode) {
            classicBtn.classList.remove('active');
            livesBtn.classList.add('active');
        } else {
            classicBtn.classList.add('active');
            livesBtn.classList.remove('active');
        }
    }
}

// üÜï Update lives display
function updateLivesDisplay() {
    const livesDisplay = document.getElementById('livesDisplay');
    const livesValue = document.getElementById('livesValue');
    
    if (livesDisplay && livesValue) {
        if (livesMode) {
            livesDisplay.style.display = 'inline-block';
            
            // Generate heart display
            let hearts = '';
            for (let i = 0; i < maxLives; i++) {
                if (i < currentLives) {
                    hearts += 'üíñ';
                } else {
                    hearts += 'ü§ç';
                }
            }
            livesValue.innerHTML = hearts;
        } else {
            livesDisplay.style.display = 'none';
        }
    }
}

// üÜï Lose one life
function loseLife(row, col) {
    currentLives--;
    
    // Show mine but do not end game
    const cellElement = getCellElement(row, col);
    if (cellElement) {
        cellElement.classList.add("mine");
        cellElement.innerHTML = "üí£";
        cellElement.style.backgroundColor = "#ff6666";
    }
    
    // Update lives display
    updateLivesDisplay();
    
    // Add lost life animation
    const livesInfo = document.getElementById('livesDisplay');
    if (livesInfo) {
        livesInfo.classList.add('life_lost');
        setTimeout(() => {
            livesInfo.classList.remove('life_lost');
        }, 600);
    }
    
    if (currentLives <= 0) {
        // Out of lives, game over
        endGame(false, 'Out of lives! Game over!');
    } else {
        // Show temporary lost life message
        showTemporaryMessage(`üíî Lost a life! ${currentLives} lives left`, 2000);
    }
}

// üÜï Show temporary message
function showTemporaryMessage(message, duration = 3000) {
    const messageElement = document.createElement('div');
    messageElement.className = 'temporary-message';
    messageElement.textContent = message;
    
    document.body.appendChild(messageElement);
    
    setTimeout(() => {
        if (messageElement.parentNode) {
            messageElement.parentNode.removeChild(messageElement);
        }
    }, duration);
}

// Difficulty switch function
function switchDifficulty(difficultyIndex) {
    // If game is in progress, prevent switching
    if (gameStarted && !gameOver) {
        console.log('Game in progress, cannot switch difficulty');
        return;
    }
    
    // Stop current game
    if (typeof endGameWithoutSaving === 'function') {
        endGameWithoutSaving();
    }
    
    // Update difficulty index
    currentDifficultyIndex = difficultyIndex;
    const currentDifficulty = DIFFICULTY[currentDifficultyIndex];
    
    // Reset game state
    gameOver = false;
    gameStarted = false;
    firstClickMade = false;
    currentLives = maxLives; // üÜï Reset lives
    
    // Update button state
    updateDifficultyButtonStyles(difficultyIndex);
    
    // Re-create game board
    createGameBoard();
    
    // Update counters
    if (typeof setTotalMines === 'function') {
        setTotalMines(currentDifficulty.number_mines);
    }
    
    // Reset timer
    if (typeof resetGameTimer === 'function') {
        resetGameTimer();
    }
    
    // üÜï Update lives display
    updateLivesDisplay();
    
    console.log(`Switched to ${currentDifficulty.name} difficulty: ${currentDifficulty.rows}√ó${currentDifficulty.columns}, ${currentDifficulty.number_mines} mines`);
}

// Update difficulty button styles
function updateDifficultyButtonStyles(activeIndex) {
    const buttons = ['easyBtn', 'mediumBtn', 'hardBtn'];
    buttons.forEach((btnId, index) => {
        const btn = document.getElementById(btnId);
        if (btn) {
            if (index === activeIndex) {
                btn.classList.add('active');
            } else {
                btn.classList.remove('active');
            }
        }
    });
}

// Create game board
function createGameBoard() {
    const gameBoardElement = document.getElementById("gameBoard");
    const currentDifficulty = DIFFICULTY[currentDifficultyIndex];
    const rows = currentDifficulty.rows;
    const cols = currentDifficulty.columns;
    
    // Clear existing game board
    gameBoardElement.innerHTML = "";
    
    // Dynamically adjust CSS grid
    gameBoardElement.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;
    gameBoardElement.style.gridTemplateRows = `repeat(${rows}, 1fr)`;
    
    // Adjust board size based on difficulty
    adjustGameBoardSize(currentDifficulty);
    
    // Create cells
    for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
            const cell = document.createElement("div");
            cell.classList.add("cell");
            cell.dataset.row = r;
            cell.dataset.col = c;
            
            cell.addEventListener("click", function() {
                handleCellClick(r, c);
            });
            
            cell.addEventListener("contextmenu", function(e) {
                e.preventDefault(); 
                handleRightClick(r, c);
            });
            
            gameBoardElement.appendChild(cell);
        }
    }
    
    initializeGameBoard();
    
    // Initial state: board is not interactive
    gameBoardElement.classList.add("game-not-started");
}

// Adjust game board size
function adjustGameBoardSize(difficulty) {
    const gameBoardElement = document.getElementById("gameBoard");
    let cellSize;
    
    // Set different cell sizes based on difficulty
    if (difficulty.name === "Easy") {
        cellSize = 5; // Larger cells for easy
    } else if (difficulty.name === "Medium") {
        cellSize = 4; // Medium size for medium
    } else if (difficulty.name === "Hard") {
        cellSize = 4; // Smaller cells for hard, fit more cells
    }
    
    const boardWidth = difficulty.columns * cellSize;
    const boardHeight = difficulty.rows * cellSize;
    
    gameBoardElement.style.width = `${boardWidth}vh`;
    gameBoardElement.style.height = `${boardHeight}vh`;
}

// Start game (called when Start button is pressed)
function startGame() {
    gameStarted = true;
    firstClickMade = false;
    currentLives = maxLives; // üÜï Reset lives
    disableDifficultyButtons(); // Disable difficulty buttons
    
    // üÜï Update lives display
    updateLivesDisplay();
    
    console.log(`Game started, mode: ${livesMode ? 'Lives Mode' : 'Classic Mode'}, difficulty buttons disabled`);
}

// Game end handler
function gameEndHandler() {
    gameStarted = false;
    gameOver = true;
}

window.addEventListener("DOMContentLoaded", () => {
    // Initialize as Easy difficulty
    switchDifficulty(0);
    
    // Initialize game mode
    switchGameMode(false); // Default to classic mode
    
    // Add difficulty button event listeners
    const easyBtn = document.getElementById('easyBtn');
    const mediumBtn = document.getElementById('mediumBtn');
    const hardBtn = document.getElementById('hardBtn');
    
    if (easyBtn) easyBtn.addEventListener('click', () => switchDifficulty(0));
    if (mediumBtn) mediumBtn.addEventListener('click', () => switchDifficulty(1));
    if (hardBtn) hardBtn.addEventListener('click', () => switchDifficulty(2));
});

// Restart button event listener
document.addEventListener("DOMContentLoaded", () => {
    const restartButton = document.getElementById("restartButton");
    if (restartButton) {
        restartButton.addEventListener("click", function () {
            restartGame();
        });
    }
});

function restartGame() {
    // Hide the restart button
    document.getElementById("restartButton").style.display = "none";
    
    // Reset game state
    gameOver = false;
    gameStarted = false;
    firstClickMade = false;
    currentLives = maxLives; // üÜï Reset lives
    
    // Re-enable difficulty buttons
    enableDifficultyButtons();

    // Re-create the current difficulty game board
    createGameBoard();
    
    // Reset mine count for the counter
    const currentDifficulty = DIFFICULTY[currentDifficultyIndex];
    if (typeof setTotalMines === 'function') {
        setTotalMines(currentDifficulty.number_mines);
    }
    
    // Show the start button
    const startButton = document.getElementById("startButton");
    if (startButton) {
        startButton.style.display = "block";
    }
    
    // üÜï Update lives display
    updateLivesDisplay();
    
    console.log('Game restarted, difficulty buttons enabled');
}

function initializeGameBoard() {
    const currentDifficulty = DIFFICULTY[currentDifficultyIndex];
    const rows = currentDifficulty.rows;
    const cols = currentDifficulty.columns;
    
    gameBoard = new Array(rows);
    for (let r = 0; r < rows; r++) {
        gameBoard[r] = new Array(cols);
        for (let c = 0; c < cols; c++) {
            gameBoard[r][c] = {
                hasMine: false,
                isRevealed: false,
                isFlagged: false,
                isQuestioned: false,  // NEW: is question-mark state
                adjacentMines: 0
            };
        }
    }
    
    // Important change: Do not place mines at initialization
    // Mines will be placed after the first click
    mineLocations = [];
    console.log('Game board initialized without mines. Mines will be placed after first click.');
}

// New function: place mines after the first click, ensuring the first click and its neighbors have no mines
function placeMinesAfterFirstClick(firstClickRow, firstClickCol) {
    const currentDifficulty = DIFFICULTY[currentDifficultyIndex];
    const rows = currentDifficulty.rows;
    const cols = currentDifficulty.columns;
    const mineCount = currentDifficulty.number_mines;
    
    // Create a list of all possible positions
    let availablePositions = [];
    for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
            availablePositions.push([r, c]);
        }
    }
    
    // Key: remove the first click position and its 8 neighbors (safe start)
    const forbiddenPositions = [];
    
    // Add the first click position
    forbiddenPositions.push([firstClickRow, firstClickCol]);
    
    // Add 8 neighbors around the first click
    for (let dr = -1; dr <= 1; dr++) {
        for (let dc = -1; dc <= 1; dc++) {
            const nr = firstClickRow + dr;
            const nc = firstClickCol + dc;
            
            // Check if in board range
            if (nr >= 0 && nr < rows && nc >= 0 && nc < cols) {
                forbiddenPositions.push([nr, nc]);
            }
        }
    }
    
    // Remove forbidden positions from available positions
    availablePositions = availablePositions.filter(([r, c]) => {
        return !forbiddenPositions.some(([fr, fc]) => fr === r && fc === c);
    });
    
    console.log(`Number of forbidden positions for mine placement: ${forbiddenPositions.length}`);
    console.log(`Number of available positions for mine placement: ${availablePositions.length}`);
    console.log(`Number of mines to place: ${mineCount}`);
    
    // Check if enough positions to place mines
    if (availablePositions.length < mineCount) {
        console.error('Error: Not enough positions to place all mines!');
        alert('Error: The board is too small to place all mines!');
        return;
    }
    
    // Shuffle available positions
    for (let i = availablePositions.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [availablePositions[i], availablePositions[j]] = [availablePositions[j], availablePositions[i]];
    }
    
    // Select the first mineCount positions to place mines
    mineLocations = [];
    for (let i = 0; i < mineCount && i < availablePositions.length; i++) {
        const [r, c] = availablePositions[i];
        gameBoard[r][c].hasMine = true;
        mineLocations.push([r, c]);
    }
    
    console.log(`Successfully placed ${mineLocations.length} mines`);
    console.log('Mine locations:', mineLocations);
    
    // After placing mines, recalculate adjacent mine numbers
    calculateAdjacentMines();
}

// Modified original placeMines function (now only used in restart that is not first click)
function placeMines() {
    // This function is now rarely used, since we place mines after the first click
    // Kept for backward compatibility
    console.log('placeMines() called - this should only happen during restart');
    
    const currentDifficulty = DIFFICULTY[currentDifficultyIndex];
    const rows = currentDifficulty.rows;
    const cols = currentDifficulty.columns;
    const mineCount = currentDifficulty.number_mines;
    
    let positions = [];
    for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
            positions.push([r, c]);
        }
    }
    
    for (let i = positions.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [positions[i], positions[j]] = [positions[j], positions[i]];
    }
    
    mineLocations = [];
    for (let i = 0; i < mineCount && i < positions.length; i++) {
        const [r, c] = positions[i];
        gameBoard[r][c].hasMine = true;
        mineLocations.push([r, c]);
    }
}

function calculateAdjacentMines() {
    const currentDifficulty = DIFFICULTY[currentDifficultyIndex];
    const rows = currentDifficulty.rows;
    const cols = currentDifficulty.columns;
    
    // First reset adjacent mine counts for all non-mine cells
    for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
            if (!gameBoard[r][c].hasMine) {
                gameBoard[r][c].adjacentMines = 0;
            }
        }
    }
    
    // Then recalculate adjacent mine numbers for all non-mine cells
    for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
            if (gameBoard[r][c].hasMine) continue;
            
            let count = 0;
            
            for (let dr = -1; dr <= 1; dr++) {
                for (let dc = -1; dc <= 1; dc++) {
                    if (dr === 0 && dc === 0) continue;
                    
                    const nr = r + dr;
                    const nc = c + dc;
                    
                    if (nr >= 0 && nr < rows && nc >= 0 && nc < cols) {
                        if (gameBoard[nr][nc].hasMine) {
                            count++;
                        }
                    }
                }
            }
            
            gameBoard[r][c].adjacentMines = count;
        }
    }
    
    console.log('Adjacent mines calculated');
}

// üÜï Modify handleCellClick to support safe start and lives mode
function handleCellClick(row, col) {
    // Check game state
    const gameBoardElement = document.getElementById("gameBoard");
    if (gameBoardElement && gameBoardElement.classList.contains("game-not-started")) {
        return; // If game hasn't started, ignore click
    }
    
    if (gameOver || gameBoard[row][col].isRevealed) return;
    // If cell is flagged or questioned, cannot left-click
    if (gameBoard[row][col].isFlagged || gameBoard[row][col].isQuestioned) return;
    
    // Key logic: if this is the first click, place mines
    if (!firstClickMade) {
        console.log(`First click position: (${row}, ${col})`);
        placeMinesAfterFirstClick(row, col);
        firstClickMade = true;
        console.log('Mines placed, game officially started!');
    }
    
    const cellElement = getCellElement(row, col);
    
    gameBoard[row][col].isRevealed = true;
    cellElement.classList.add("revealed");
    
    // Increase explored cell count
    if (typeof addExploredCell === 'function') {
        addExploredCell();
    }
    
    if (gameBoard[row][col].hasMine) {
        // üÜï Handle mine hit according to game mode
        if (livesMode && currentLives > 1) {
            // Lives mode: lose a life but continue
            loseLife(row, col);
        } else {
            // Classic mode or out of lives: end game
            cellElement.classList.add("mine");
            cellElement.innerHTML = "üí£";
            if (livesMode) {
                endGame(false, 'Out of lives! Game over!');
            } else {
                endGame(false);
            }
        }
    } else {
        const adjacentMines = gameBoard[row][col].adjacentMines;
        if (adjacentMines > 0) {
            cellElement.textContent = adjacentMines;
            cellElement.classList.add(`adjacent-${adjacentMines}`);
        } else {
            revealSurroundingCells(row, col);
        }
        checkForWin();
    }
}

function handleRightClick(row, col) {
    // Check game state
    const gameBoardElement = document.getElementById("gameBoard");
    if (gameBoardElement && gameBoardElement.classList.contains("game-not-started")) {
        return; // If game hasn't started, ignore right-click
    }
    
    if (gameOver || gameBoard[row][col].isRevealed) return;
    
    const cellElement = getCellElement(row, col);
    
    // Cycle through three states: unmarked ‚Üí flag ‚Üí question ‚Üí unmarked
    if (!gameBoard[row][col].isFlagged && !gameBoard[row][col].isQuestioned) {
        // State 1: unmarked ‚Üí flag
        gameBoard[row][col].isFlagged = true;
        gameBoard[row][col].isQuestioned = false;
        cellElement.classList.add("flagged");
        cellElement.classList.remove("questioned");
        cellElement.innerHTML = "üö©";
        
        // Increase flag count
        if (typeof addFlag === 'function') {
            addFlag();
        }
        
    } else if (gameBoard[row][col].isFlagged && !gameBoard[row][col].isQuestioned) {
        // State 2: flag ‚Üí question
        gameBoard[row][col].isFlagged = false;
        gameBoard[row][col].isQuestioned = true;
        cellElement.classList.remove("flagged");
        cellElement.classList.add("questioned");
        cellElement.innerHTML = "‚ùì";
        
        // Decrease flag count (from flag to question)
        if (typeof removeFlag === 'function') {
            removeFlag();
        }
        
    } else if (!gameBoard[row][col].isFlagged && gameBoard[row][col].isQuestioned) {
        // State 3: question ‚Üí unmarked
        gameBoard[row][col].isFlagged = false;
        gameBoard[row][col].isQuestioned = false;
        cellElement.classList.remove("flagged");
        cellElement.classList.remove("questioned");
        cellElement.innerHTML = "";
        
        // No counter change when question mark becomes unmarked
    }
    
    checkForWin();
}

function revealSurroundingCells(row, col) {
    const currentDifficulty = DIFFICULTY[currentDifficultyIndex];
    const rows = currentDifficulty.rows;
    const cols = currentDifficulty.columns;
    
    for (let dr = -1; dr <= 1; dr++) {
        for (let dc = -1; dc <= 1; dc++) {
            if (dr === 0 && dc === 0) continue;
            
            const nr = row + dr;
            const nc = col + dc;
            
            if (nr >= 0 && nr < rows && nc >= 0 && nc < cols && 
                !gameBoard[nr][nc].isRevealed && 
                !gameBoard[nr][nc].isFlagged && 
                !gameBoard[nr][nc].isQuestioned) {
                handleCellClick(nr, nc);
            }
        }
    }
}

function getCellElement(row, col) {
    return document.querySelector(`.cell[data-row="${row}"][data-col="${col}"]`);
}

function checkForWin() {
    if (gameOver) return;
    
    const currentDifficulty = DIFFICULTY[currentDifficultyIndex];
    const rows = currentDifficulty.rows;
    const cols = currentDifficulty.columns;
    const totalCells = rows * cols;
    const totalMines = currentDifficulty.number_mines;
    
    let revealedCount = 0;
    for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
            if (gameBoard[r][c].isRevealed && !gameBoard[r][c].hasMine) {
                revealedCount++;
            }
        }
    }
    
    if (revealedCount === totalCells - totalMines) {
        endGame(true);
    }
}

// üÜï Modify endGame to support custom message and lives mode storage
function endGame(isWin, customMessage = null) {
    gameOver = true;
    gameStarted = false;
    
    // Re-enable difficulty buttons
    gameEndHandler();
    
    // Stop timer (if exists)
    if (typeof stopGameTimer === 'function') {
        stopGameTimer();
    }
    
    // Hide End Game button
    const endButton = document.getElementById("endButton");
    if (endButton) {
        endButton.style.display = "none";
    }
    
    revealAllMines();
    document.getElementById("restartButton").style.display = "block";
    
    setTimeout(() => {
        const currentDifficulty = DIFFICULTY[currentDifficultyIndex];
        let message;
        
        if (customMessage) {
            message = customMessage;
        } else if (isWin) {
            const modeText = livesMode ? `Lives Mode` : 'Classic Mode';
            message = `üéâ Congratulations! You win!\nMode: ${modeText}\nDifficulty: ${currentDifficulty.name}`;
            if (livesMode) {
                message += `\nLives left: ${currentLives}`;
            }
        } else {
            const modeText = livesMode ? `Lives Mode` : 'Classic Mode';
            message = `üí• Game over!\nMode: ${modeText}\nDifficulty: ${currentDifficulty.name}`;
        }
        
        alert(message);
        
        // üÜï Save score (including lives mode data)
        if (typeof saveTimerValue === 'function' && typeof gameSeconds !== 'undefined') {
            // Format time
            const hours = Math.floor(gameSeconds / 3600);
            const minutes = Math.floor((gameSeconds % 3600) / 60);
            const secs = gameSeconds % 60;
            
            const formattedTime = [
                hours.toString().padStart(2, '0'),
                minutes.toString().padStart(2, '0'),
                secs.toString().padStart(2, '0')
            ].join(':');
            
            // üÜï Save to the corresponding storage key (lives mode uses separate key)
            if (livesMode) {
                saveLivesModeScore(formattedTime, gameSeconds, isWin, currentDifficulty);
            } else {
                saveTimerValue(formattedTime, gameSeconds, isWin, currentDifficulty);
            }
            
            const modeText = livesMode ? 'Lives Mode' : 'Classic Mode';
            if (isWin) {
                console.log(`üèÜ Player won in ${modeText} on ${currentDifficulty.name} difficulty! Time: ${formattedTime} (${gameSeconds} seconds)`);
            } else {
                console.log(`üí• Game lost in ${modeText} on ${currentDifficulty.name} difficulty, time: ${formattedTime} (${gameSeconds} seconds)`);
            }
        }
    }, 500);
}

// üÜï Dedicated save function for lives mode
function saveLivesModeScore(formattedTime, totalSeconds, isWin, difficulty) {
    try {
        const currentPlayer = localStorage.getItem('current_player');
        
        // Lives mode score data object
        const scoreData = {
            totalSeconds: totalSeconds,
            formattedTime: formattedTime,
            player: currentPlayer || 'anonymous',
            date: new Date().toISOString(),
            status: isWin ? 'win' : 'lost',
            isWin: isWin,
            difficulty: difficulty.name,
            difficultyId: difficulty.id,
            gameMode: 'lives',                    // üÜï Game mode flag
            gridSize: `${difficulty.rows}x${difficulty.columns}`,
            totalMines: difficulty.number_mines,
            finalLives: currentLives,             // üÜï Final lives left
            livesLost: maxLives - currentLives,   // üÜï Number of lives lost
            exploredCells: typeof exploredCells !== 'undefined' ? exploredCells : 0,
            totalSafeCells: (difficulty.rows * difficulty.columns) - difficulty.number_mines,
            flagsUsed: typeof flagsUsed !== 'undefined' ? flagsUsed : 0
        };
        
        // üÜï Use dedicated storage key for lives mode
        const storageKey = `minesweeper_lives_${difficulty.id}`;
        const existingScores = JSON.parse(localStorage.getItem(storageKey) || '[]');
        existingScores.push(scoreData);
        localStorage.setItem(storageKey, JSON.stringify(existingScores));
        
        console.log(`Lives mode ${difficulty.name} difficulty score saved (${isWin ? 'win' : 'lose'}):`, scoreData);
        
    } catch (error) {
        console.error('Error saving lives mode score:', error);
    }
}

function revealAllMines() {
    mineLocations.forEach(([r, c]) => {
        const cellElement = getCellElement(r, c);
        
        if (!gameBoard[r][c].isRevealed) {
            cellElement.classList.add("revealed", "mine");
            cellElement.innerHTML = "üí£";
        }
    });
}

// Reset game board (do not save data)
function resetGameBoard() {
    // Reset game state
    gameOver = false;
    gameStarted = false;
    firstClickMade = false;
    currentLives = maxLives; // üÜï Reset lives
    
    // Re-enable difficulty buttons
    enableDifficultyButtons();

    // Re-create the current difficulty game board
    createGameBoard();
    
    // üÜï Update lives display
    updateLivesDisplay();
}
